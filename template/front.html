<div id="context">{{Context}}</div>

<div id="question">{{Question}}</div>

<div id="answer-front">{{Answer}}</div>

<div id="answer-proposal-container"></div>

<div id="answer-choice-container"></div>

<div id="mix-in-container-front">{{Mix-in answer}}</div>

<div id="options">{{Options}}</div>

<script>
// v1.1.8 - https://github.com/SimonLammer/anki-persistence/blob/584396fea9dea0921011671a47a0fdda19265e62/script.js
if(void 0===window.Persistence){var e="github.com/SimonLammer/anki-persistence/",t="_default";if(window.Persistence_sessionStorage=function(){var i=!1;try{"object"==typeof window.sessionStorage&&(i=!0,this.clear=function(){for(var t=0;t<sessionStorage.length;t++){var i=sessionStorage.key(t);0==i.indexOf(e)&&(sessionStorage.removeItem(i),t--)}},this.setItem=function(i,n){void 0==n&&(n=i,i=t),sessionStorage.setItem(e+i,JSON.stringify(n))},this.getItem=function(i){return void 0==i&&(i=t),JSON.parse(sessionStorage.getItem(e+i))},this.removeItem=function(i){void 0==i&&(i=t),sessionStorage.removeItem(e+i)},this.getAllKeys=function(){for(var t=[],i=Object.keys(sessionStorage),n=0;n<i.length;n++){var s=i[n];0==s.indexOf(e)&&t.push(s.substring(e.length,s.length))}return t.sort()})}catch(n){}this.isAvailable=function(){return i}},window.Persistence_windowKey=function(i){var n=window[i],s=!1;"object"==typeof n&&(s=!0,this.clear=function(){n[e]={}},this.setItem=function(i,s){void 0==s&&(s=i,i=t),n[e][i]=s},this.getItem=function(i){return void 0==i&&(i=t),void 0==n[e][i]?null:n[e][i]},this.removeItem=function(i){void 0==i&&(i=t),delete n[e][i]},this.getAllKeys=function(){return Object.keys(n[e])},void 0==n[e]&&this.clear()),this.isAvailable=function(){return s}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey("py")),!Persistence.isAvailable()){var i=window.location.toString().indexOf("title"),n=window.location.toString().indexOf("main",i);i>0&&n>0&&n-i<10&&(window.Persistence=new Persistence_windowKey("qt"))}}

  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
  }

  // For now options can be
  // - "unordered": for any set of choices among several
  // - "multiline": when the answer is supposed to be several lines (like prose). It is just a formatting option for the output
  // - "one-word": for spelling things
  // - "polyline": for things like verb conjugation, where you have a list of lists. Expected format is then <ul><li>top level 1</li><ul>list of answers for 1</ul> etc
  // - TODO: I likely will want formulas, but that can be tricky
  // - TODO: I don't enforce options being exclusive; at the moment they implicitly are

  // TODO: should I remove the numbers when unordered? Can be useful if the number of correct thingis is given as a hint!

  question = document.getElementById("question");
  hint = document.createElement("DIV");
  hint.classList.add("hint");

  options = document.getElementById("options").textContent;

  // I was initially "smart splitting", using spaces and pipes as separators. By using an HTML list
  // as the structure, I can unify all options. It looks a bit horrible when editing answers, but it
  // is way easier _and_ allows for images as answers/options easily

  function conditionallySplitAnswer() {
    const answer = document.getElementById("answer-front");
    const answerText = answer.textContent;
    const answerList = Array.from(answer.querySelectorAll("LI"));
    return answerList;
  }

  function conditionallySplitMixins() {
    const mixins = document.getElementById("mix-in-container-front");
    const mixinsText = mixins.textContent;
    let mixinsList = Array.from(mixins.querySelectorAll("LI"));
    mixinsList = mixinsList.concat(conditionallySplitAnswer());
    shuffle(mixinsList);
    return mixinsList;
  }

  mixins = conditionallySplitMixins();

  answer = conditionallySplitAnswer();

  if (options.includes("unordered")) {
    hint.textContent = `(${answer.length})`;
    question.appendChild(hint);
  }

  answerChoiceContainer = document.getElementById("answer-choice-container");
  answerProposalContainer = document.getElementById(
    "answer-proposal-container"
  );

  answerCounter = 0;
  answerArray = [];

  // Presents a random selection of the mixins (all of them) and the answer words.
  // TODO: pick a smaller number out of mixins (min 3 or 4 likely)

  for (const mixin of mixins) {
    const a = document.createElement("A");
    a.innerHTML = mixin.innerHTML;
    a.addEventListener("click", () => {
      if (a.classList.contains("clicked")) {
        if (!options.includes("polyline")) {
          // TODO handling of removal of styles in one-word is not great (edges fail)
          a.classList.remove("clicked");
          a.classList.remove("squash-all");
          a.classList.remove("squash-right");
          a.classList.remove("squash-left");
          answerChoiceContainer.appendChild(a);
          answerArray = answerArray.filter((e) => e != mixin.innerHTML);
        } else {
          a.classList.remove("clicked");
          answerChoiceContainer.appendChild(a);
          answerArray = answerArray.filter((e) => e != mixin.innerHTML);

          // Remove all unused subdivs
          const subDivs =
            answerProposalContainer.querySelectorAll("DIV.blocked");

          subDivs.forEach((subDiv) => {
            if (subDiv.children.length === 0) {
              subDiv.remove();
            }
          });
        }
      } else {
        if (!options.includes("polyline")) {
          answerProposalContainer.appendChild(a);
        } else {
          a.classList.add("inlined");
          const answerDiv = document.getElementById("answer-front");
          console.log(answerDiv);
          const topLevel = Array.from(
            answerDiv.querySelector("UL").querySelectorAll("UL")
          );
          // This is strange yes, the structure is UL > LI UL, no nesting
          console.log(answerProposalContainer);
          const currentDivBlocks =
            answerProposalContainer.querySelectorAll("DIV.blocked");
          console.log("current div blocks first");
          console.log(currentDivBlocks);
          console.log(topLevel);
          const idx = currentDivBlocks.length - 1;
          if (currentDivBlocks.length == 0) {
            const div = document.createElement("DIV");
            answerDiv.appendChild(div);
            div.classList.add("blocked");
            div.appendChild(a);
            answerProposalContainer.appendChild(div);
          } else {
            console.log("Else case");
            // Get the numbers of LIs under the LI and the number of As in the div.
            // You should have one more A: the header
            console.log(currentDivBlocks);
            console.log(idx);
            console.log("As, Toplevel and Lis");
            const divAs = currentDivBlocks[idx].querySelectorAll("A.inlined");
            console.log(divAs);
            console.log(topLevel);
            const ansLis = topLevel[idx].querySelectorAll("LI");
            console.log(ansLis);
            if (divAs.length >= ansLis.length + 1) {
              const div = document.createElement("DIV");
              answerDiv.appendChild(div);
              div.classList.add("blocked");
              div.appendChild(a);
              answerProposalContainer.appendChild(div);
            } else {
              currentDivBlocks[idx].appendChild(a);
            }
          }
        }
        a.classList.add("clicked");
        answerArray.push(mixin.innerHTML);
        if (options.includes("one-word")) {
          if (answerArray.length >= 2) {
            a.classList.add("squash-left");
          }
          if (answerArray.length > 2) {
            a.previousSibling.classList.add("squash-all");
          } else {
            a.previousSibling.classList.add("squash-right");
          }
        }
      }
      Persistence.setItem(answerArray);
    });
    answerChoiceContainer.appendChild(a);
  }
</script>
